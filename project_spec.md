# Bybit P2P Analytics — MVP spec (RUB → USDT → VND)

Дата: 2026-02-09  
Источник требований: `brainstorm.md`, `most_important_answers.md`

## Part 1 — Product requirements

## 0) TL;DR

Сервис собирает (скрейпит) публичные объявления Bybit P2P по `USDT/RUB` и `USDT/VND`, считает “лучший исполнимый” курс:
- покупки USDT за RUB,
- продажи USDT за VND,
и показывает текущие цены/ликвидность + лучшие окна по времени суток (на исторических данных) **для каждой ноги отдельно**.

## 1) Пользователь и задача

**Пользователь:** один (персональное использование).

**Задача:** максимизировать итоговый курс конвертации зарплаты в RUB в траты/накопления в VND через USDT:
- купить USDT за RUB (P2P, выбранные методы оплаты),
- продать USDT за VND (P2P, выбранные методы оплаты).

**Частота:** пару раз в месяц, суммы крупные, можно ждать лучшего курса днями.

## 2) Успех (MVP KPI)

MVP считается успешным, если:
1) Система стабильно собирает данные без дыр (или с явной сигнализацией, что сбор сломался).
2) Для заданных фильтров и суммы показывает корректный “исполняемый” курс (учитывает min/max лимиты объявлений).
3) Даёт понятный ответ на вопрос “когда выгоднее” (лучшие часы/окна) на базе истории.

## 3) Scope MVP

### 3.1 Must-have

- Скрейпер публичных P2P объявлений (RUB/VND, buy/sell) с периодом **30 секунд**.
- Raw-хранилище всех ответов (для пере-парсинга и проверки).
- Парсер → нормализованные `Offer` записи.
- Аналитика:
  - `best_single_offer_price` (1 контрагент) и “достаточно ли под сумму”.
  - `best_split_vwap_price` (разбиение на несколько сделок) хотя бы в режиме “greedy” + валидация лимитов.
  - таймсерии и агрегаты (час/день недели) по ногам:
    - `best_rub_per_usdt` (покупка USDT за RUB),
    - `best_vnd_per_usdt` (продажа USDT за VND).
  - базовые прокси ликвидности (`near_best_liquidity`, `offer_half_life`).
- UI (достаточно локального): дашборд с фильтрами и графиками.

### 3.2 Not in MVP (явно)

- Автоисполнение сделок.
- Авторизация в Bybit / работа с аккаунтом / хранение ключей.
- Сбор любой PII (реквизиты, имена и т.п.).
- “Истинные объёмы сделок” (их может не быть публично) — только прокси.
- Пуш-уведомления/боты (можно добавить позже).
- “Комбо сейчас” `RUB → USDT → VND` и метрика `effective_vnd_per_rub` (можно добавить после MVP).

## 4) Входные параметры (то, что пользователь выбирает)

### 4.1 Суммы

- `buy_amount_rub`: 20_000 … 100_000 RUB (частый диапазон).
- `sell_amount_usdt`: сумма USDT, которую планируется продать за VND (по умолчанию можно вычислять как `buy_amount_rub / median(RUB/USDT)`; и позволить вручную задать).

В MVP:
- экран “Купить USDT за RUB” использует `buy_amount_rub`,
- экран “Продать USDT за VND” использует `sell_amount_usdt`.

### 4.2 Фильтры

Общие:
- `merchant_only`: по умолчанию **false** (анализируем и мерчантов, и обычных).
- `min_rating`: по умолчанию `0` (или “нет фильтра”), но иметь ползунок/ввод.
- `max_splits`: по умолчанию `3` (пользователь готов дробить).

RUB-leg (покупка USDT за RUB):
- методы оплаты: **СБП**, **перевод на карту**.

VND-leg (продажа USDT за VND):
- метод оплаты: **bank transfer** на местный банк.

### 4.3 Временная зона

- Хранить все события в UTC.
- Отображать/агрегировать по **Asia/Ho_Chi_Minh (UTC+7)** (config).

## Part 2 — Technical design

## 5) Данные и сбор

### 5.1 Источник данных

Публичный список P2P объявлений Bybit (ads/offers). Доступ через:
- JSON endpoint’ы, которые использует веб-приложение (предпочтительно; можно взять из Chrome DevTools),
- или HTML + парсинг (fallback),
- или headless browser (Playwright) как резерв, если JSON недоступен.

### 5.2 Матрица запросов

Минимальный набор “рынков”, которые собираем:
- `fiat=RUB`, `asset=USDT`, `side=SELL` (пользователь покупает USDT).
- `fiat=RUB`, `asset=USDT`, `side=BUY` (для спреда/контекста).
- `fiat=VND`, `asset=USDT`, `side=BUY` (пользователь продаёт USDT).
- `fiat=VND`, `asset=USDT`, `side=SELL` (для спреда/контекста).

Страницы:
- собирать до `P` страниц (по умолчанию `P=5`), чтобы после фильтрации было ≥ `M` офферов (`M=30`).

### 5.3 Raw слой (обязательно)

Каждый fetch сохраняется как запись:
- `ts_utc`
- `market_key` (fiat/asset/side)
- `request_params` (page, page_size, фильтры если применяются на сервере)
- `http_status`
- `response_body` (как есть, лучше сжатие)
- `parse_version` (чтобы отслеживать изменения схемы)

### 5.4 Нормализованный слой: `Offer`

Минимальные поля:
- `ts_utc`
- `fiat` (`RUB`/`VND`)
- `asset` (`USDT`)
- `side` (`BUY`/`SELL`) — сторона объявления
- `price_fiat_per_usdt`
- `min_fiat`, `max_fiat`
- `available_usdt` (если доступно в листинге; иначе `null`, в MVP не открываем каждое объявление отдельно)
- `payment_methods[]` (нормализованные ключи)
- `is_merchant` (bool)
- `rating` (float/nullable)
- `advertiser_key` (если есть; иначе хэш из публичного имени + признаков)
- `raw_id` / ссылка на raw запись

## 6) Определения и метрики (MVP)

### 6.1 “Исполнимость” под сумму

Объявление считается подходящим, если проходит пользовательские фильтры (payment, merchant_only, min_rating) и:
- для **покупки USDT за fiat** (мы платим fiat): `min_fiat <= amount_fiat <= max_fiat`
- для **продажи USDT за fiat** (мы продаём USDT и получаем fiat): `min_fiat <= (amount_usdt * price_fiat_per_usdt) <= max_fiat`

### 6.2 Лучший курс для 1 сделки (single-offer)

Для операции “Купить USDT за RUB”:
- берём объявления `fiat=RUB` и **side=SELL**,
- выбираем минимальный `price_rub_per_usdt` среди подходящих под `buy_amount_rub`.

Для операции “Продать USDT за VND”:
- берём объявления `fiat=VND` и **side=BUY**,
- выбираем максимальный `price_vnd_per_usdt` среди объявлений, где `min_vnd <= sell_amount_usdt * price_vnd_per_usdt <= max_vnd`.

### 6.3 Разбиение на несколько сделок (split VWAP)

Цель:
- для `buy_amount_rub` (покупка USDT за RUB) — найти набор из ≤ `max_splits` объявлений, чтобы суммарно купить USDT на `buy_amount_rub` (с учётом min/max каждого объявления) и минимизировать среднюю цену (VWAP) `RUB/USDT`.
- для `sell_amount_usdt` (продажа USDT за VND) — найти набор из ≤ `max_splits` объявлений, чтобы продать `sell_amount_usdt` (с учётом min/max в VND у каждого объявления) и максимизировать VWAP `VND/USDT`.

MVP алгоритм (достаточно, чтобы получить рабочую оценку):
1) Отсортировать подходящие объявления по цене (лучшие сверху).
2) Greedy-наполнение: брать максимум из лучшего объявления, затем следующего и т.д.
3) После распределения проверить ограничения min/max; если какое-то объявление использовано ниже `min_fiat`, попытаться перераспределить (простая корректировка) или откатиться на `single-offer`.

Примечание: если `available_usdt` отсутствует, считать вместимость только по `max_fiat`.

### 6.4 Пост-MVP: `effective_vnd_per_rub` (комбо)

После MVP можно добавить “комбо” расчёт `RUB → USDT → VND`:
1) Купить `usdt_bought(t)` за `buy_amount_rub` (single/split) → `avg_rub_per_usdt(t)`.
2) Продать `usdt_bought(t)` за VND (single/split) → `vnd_received(t)` и `avg_vnd_per_usdt(t)`.

Тогда:
- `effective_vnd_per_rub(t) = vnd_received(t) / buy_amount_rub`

### 6.5 Прокси ликвидности

- `near_best_liquidity_xpct`: сколько суммы можно провести в пределах `X%` от лучшей цены (по умолчанию `X=0.5%`).
- `offer_half_life`: медианное время “жизни” top-1 оффера (по `advertiser_key+price`, либо по `raw_id`/позиции), измеряется по исчезновению из выборки.
- `top_stability`: доля времени, когда top-1 не меняется.

## 7) Аналитика “когда лучше”

MVP отчёты/графики:
- **RUB-leg (покупка USDT за RUB):**
  - таймсерия `best_rub_per_usdt` (single/split), где ниже = лучше,
  - heatmap по часу суток × дню недели (медиана и p10),
  - “лучшие окна” по минимальной цене + проверка ликвидности под `buy_amount_rub`.
- **VND-leg (продажа USDT за VND):**
  - таймсерия `best_vnd_per_usdt` (single/split), где выше = лучше,
  - heatmap по часу суток × дню недели (медиана и p90),
  - “лучшие окна” по максимальной цене + проверка ликвидности под `sell_amount_usdt`.

Baseline сравнение (для проверки пользы):
- “покупаю в случайный час” vs “покупаю в рекомендованный час”.

## 8) UI (локальный дашборд)

Минимальные экраны/блоки:

1) **Текущая выгода**
- Ввод `buy_amount_rub` и `sell_amount_usdt` (в зависимости от экрана)
- Фильтры (payment RUB, payment VND, merchant_only, min_rating, max_splits)
- Карточки:
  - “Купить USDT за RUB” (best single/split + ликвидность)
  - “Продать USDT за VND” (best single/split + ликвидность)
- “Достаточно ли ликвидности под сумму” (да/нет + причина)
- Таблица top-5 офферов для каждого leg (с подсветкой лучшего)

2) **История**
- Графики для RUB-leg и VND-leg
- Heatmap time-of-day (отдельно по leg’ам)
- Список “лучших окон” + ожидаемое улучшение + ликвидность

3) **Качество данных**
- индикатор дыр/ошибок скрейпа
- последние ошибки парсинга

## 9) Хранение и обработка (рекомендация для MVP)

Цель: простота + возможность пересчёта метрик.

Рекомендуемый вариант:
- Raw: `data/raw/YYYY-MM-DD/*.jsonl.gz` (по market_key/page)
- Processed: `data/processed/offers.parquet` (партиции по дате/fiat/side)
- Query: DuckDB (быстрые агрегации для дашборда)

Допустимая упрощённая альтернатива:
- SQLite (raw blobs + offers table), если объёмы небольшие.

## 10) Надёжность и проверки

Авто-checks (запускать при каждой обработке дня):
- “дыры” больше 2 минут в расписании → alert в UI.
- резкое падение числа офферов / пустые страницы → вероятно сломался сбор.
- изменения схемы ответа → увеличить `parse_version` и сохранить raw для дебага.

## 11) Риски и допущения

- Скрейпинг может ломаться из‑за изменений сайта/эндпоинтов → нужен raw слой и быстрая адаптация парсера.
- Цена/ликвидность в P2P ≠ гарантированное исполнение (контрагент может отменить).
- Прокси объёмов/ликвидности могут ошибаться, если `available_usdt` не публикуется.

## 12) План работ (MVP)

1) Определить доступный источник данных (JSON endpoint vs HTML vs Playwright) и зафиксировать `request matrix`.
2) Реализовать collector (30с) + raw storage.
3) Реализовать парсер → `Offer` и базовые quality checks.
4) Реализовать расчёт `best_*` (single + split) для RUB-leg и VND-leg.
5) Реализовать дашборд (Текущая выгода + История + Качество данных).
6) Прогнать 7–14 дней сбора и построить первый heatmap/рекомендации.

## 13) Открытые вопросы (TBD)

1) Какая “типичная” сумма USDT для продажи за VND (или оставляем только derivation из `buy_amount_rub`)?
2) Нужно ли учитывать комиссии/доп. расходы (по умолчанию 0).
3) Какие пороги “min_rating” считаются приемлемыми (например 0/4.5/4.8)?
4) Какие методы оплаты исключать жёстко (если появятся нежелательные).
